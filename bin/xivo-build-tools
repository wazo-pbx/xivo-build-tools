#!/bin/bash
set -e

if [ $EUID == 0 ]; then
	echo "This script must not be run as root" 1>&2
	exit 1
fi

CONF_FILE="/etc/xivo-build-tools/config"

# source conffile
if [ -e $CONF_FILE ]; then
	. $CONF_FILE
else
	echo "$CONF_FILE: no such file" >&2
	exit 1
fi

export NAME="$DEBFULLNAME"
export EMAIL="$DEBEMAIL"

usage() {
	cat << EOF
You have to provide some informations to allow building:

	Usage: $(basename $0) [OPTION]

	Options:
		-d <distribution>: Distribution where to upload package (default: $DISTRIBUTION_DEFAULT)
		-b <branch_name>: Git branch to build from (default: $GIT_BRANCH_DEFAULT)
		-m <mirror>: Mirror where to upload package (default: $MIRROR_DEFAULT)
		-a: Build all packages
		-p <package>: Build only <package>
		-f: Force package build without checking for changes in repository
		-v: Set xivo version (default: $VERSION_DEFAULT)
		-u: Use xivo version in filename (default: False)
		-h: show this help

EOF
	exit 0
}

valid_package() {
	local package="$1"

	if [[ $PACKAGES =~ $package ]]; then
		return 0
	else
		echo "Package: $package does not exist, see $CONF_FILE for more informations" >&2
		exit -1
	fi
}

cd_to_git_dir_package() {
	local package="$1"
	
	local package_dir="${PACKAGES_DIR}/${package}"
	
	if [ -d "${package_dir}/${package}" ]; then
		cd "${package_dir}/${package}"
	else
		cd "${package_dir}"
	fi
	return 0
}

git_remote_branch_exist() {
	local remote_branch="$1"

	git branch -r | grep -q "origin/$remote_branch"
	return $?
}

get_mirror_package_version() {
	local package="$1"
	local mirror_uri="dists/${distribution}/main/binary-${ARCH}/Packages"

	case $package in
		"xivo-provisioning") local package="xivo-provd";;
		"xivo-dao") local package="xivo-libdao";;
		"xivo-dird") local package="xivo-libdird";;
	esac

	wget -qO- ${MIRROR_URL}/${mirror_uri} | grep -A 2 "^Package: $package" | grep '^Version:' | head -n1 | awk '{print $2}'
	return 0
}

get_source_version() {
	local package="$1"

	cd_to_git_dir_package $package
	
	# using date now instead of commit date
	#local git_timestamp=$(git log -1 --pretty='%ct')
	local now_timestamp=$(date +%s)
	local timestamp=$(perl -MPOSIX -e 'print strftime("%Y%m%d.%H%M%S", gmtime('${now_timestamp}'))')
	local git_hash=$(git log -1 --pretty='%h')
	local computed="~${timestamp}.${git_hash}"

	if [ $use_version -eq 0 ]; then
		echo ${version}${computed}
	else
		echo ${computed}
	fi
	return 0
}

get_debian_version() {
	local package="$1"
	local source_version="$2"

	cd_to_git_dir_package $package

	local existing_version=$(get_mirror_package_version $package) || return 1

	if [ -z "$existing_version" ]; then
		# look for a package version
		local changelog=$(head -1 debian/changelog)
		if [[ "$changelog" =~ \((.*)\) ]] ; then
			existing_version=${BASH_REMATCH[1]}
		else
			echo "The first line of $dir/changelog is '$changelog' and does not match \\(.*\\)" >&2
			return 1
		fi
		# sanity check on the package name
		if ! [[ "$changelog" =~ ^$package ]] ; then
			echo "The first line of $dir/changelog is '$changelog' and does not start with $package" >&2
			return 2
		fi
	fi

	# extract the epoch, if any
	local epoch
	if [[ "$existing_version" =~ ([0-9]+:) ]] ; then
		epoch=${BASH_REMATCH[1]}
	fi

	local debian
	if echo "$existing_version" | grep -q $source_version ; then
		if [[ "$existing_version" =~ .*-(.*) ]] ; then
			debian="-$(expr ${BASH_REMATCH[1]} + 1)"
		else
			debian=-1
		fi
	else
		debian=-1
	fi

	local version=${epoch}${source_version}${debian}

	if ! dpkg --compare-versions $existing_version le $version ; then
		echo "Existing version of XiVO is ($existing_version) that is greater or equal (according to dpkg --compare-versions) than the version computed ($version)" >&2
		return 4
	fi

	echo $version
	return 0
}

genreate_changelog() {
	local package="$1"
	local version="$2"

	echo "Generating changelog for package $package with version $version"

	cd_to_git_dir_package $package
	
	local message="$(git log -1 HEAD --pretty=format:%s)"
	dch -v $version --distribution $distribution --force-distribution "$message"
	return 0
}

install_build_depends() {
	local package="$1"

	cd_to_git_dir_package $package

	dpkg-checkbuilddeps |& awk -F: '{print $3}' | xargs sudo apt-get install -y
	return 0
}

build_package() {
	local package="$1"

	install_build_depends $package
	cd_to_git_dir_package $package

	dpkg-buildpackage
	return 0
}

clean_package() {
	local package="$1"

	cd_to_git_dir_package $package

	dh_clean
	return 0
}

build_dput_conf() {
	local dput_file="$1"
	
	cp ${DPUT_TPL_FILE} $dput_file
	sed -i "s|{{ distribution }}|${distribution}|g" $dput_file
	sed -i "s|{{ fqdn }}|${MIRROR_HOST}|g" $dput_file
	sed -i "s|{{ incoming }}|${MIRROR_INCOMING}|g" $dput_file
	return 0
}

upload_to_mirror() {
	local package="$1"
	local version="$2"
	local version=$(echo "$version" | awk -F ':' '{print $NF}')
	local changes_file="${package}_${version}_${ARCH}.changes"
	local dput_file="/tmp/dput/${package}.cf"

	cd_to_git_dir_package $package
	build_dput_conf $dput_file
	dput -c $dput_file $distribution $changes_file
	return 0
}

process_packages() {
	for package in $PACKAGES; do
		process_package $package
	done
}

package_is_up_to_date() {
	local package="$1"

	echo "Checking updated package: $package"

	valid_package $package

	cd_to_git_dir_package $package

	git fetch origin
	local need_update="$(git log HEAD..origin/$branch_name_builded --oneline)"

	if [ "$need_update" == "" ]; then
		echo "Package $package already up-to-date."
		return 0
	else
		echo "Package $package needs update."
		git reset --hard
		git checkout $branch_name_builded
		git pull
		return 1
	fi
}

extract_branch_infos() {
	local package="$1"

	echo "Extracting branch infos for package: $package"

	branch_name_builded="$branch_name"

	cd_to_git_dir_package $package

	if ! git_remote_branch_exist $branch_name ; then
		echo "Remote branch $branch_name not exist, switch to default branch master"
		branch_name_builded="master"
	fi

	echo "$package fetch branch: <${branch_name_builded}>"
	return 0
}

prepare_repository() {
	local package="$1"

	echo "Initializing package: $package"

	cd $PACKAGES_DIR
	if [ ! -d "${package}/.git" ]; then
		echo "Cloning repository..."
		git clone ${GIT_URL}/$package
		force_rebuild=1
	fi
	cd $package
	git clean -fxd
	git reset --hard
	return 0
}

process_package() {
	local package="$1"

	echo "Processing $package"

	prepare_repository $package

	if ! extract_branch_infos $package; then
		return 1
	fi

	if [ $force_rebuild -eq 0 ] && package_is_up_to_date $package; then
		echo
		return 0
	fi

	local source_version=$(get_source_version $package) || return 1
	local debian_version=$(get_debian_version $package $source_version) || return 1
	if [ -z "$debian_version" ]; then
		exit 1
	fi

	genreate_changelog $package $debian_version
	build_package $package
	clean_package $package
	[ $? == 0 ] && upload_to_mirror $package $debian_version
	return 0
}

validate_repo_name() {
	local var="$1"
	case "$var" in
	 *\ * )
		echo "ERROR: Invalid repository name, space is not allowed" >&2
		exit 1
		;;
	*_* )
		echo "ERROR: Invalid repository name, underscore is not allowed" >&2
		exit 1
		;;
	*)
		return 0
		;;
	esac
}

if [ -z "$1" ]; then
	usage
fi

while getopts :d:p:v:b:m:afh opt
do
	case $opt in
		d) distribution=$OPTARG;;
		p) force_package=$OPTARG;;
		v) force_version=$OPTARG;;
		b) branch_name=$OPTARG;;
		m) conf_mirror=$OPTARG;;
		a) all=1;;
		f) force_rebuild=1;;
		u) use_version=1;;
		h) usage;;
		'?') echo "$0 : option $OPTARG is not valid" >&2
			usage
		;;
	esac
done

distribution="${distribution:-"${DISTRIBUTION_DEFAULT}"}"
branch_name="${branch_name:-"${GIT_BRANCH_DEFAULT}"}"
conf_mirror="${conf_mirror:-"${MIRROR_DEFAULT}"}"
version="${force_version:-"${VERSION_DEFALUT}"}"
all="${all:-"0"}"
force_rebuild="${force_rebuild:-"0"}"
use_version="${use_version:-"0"}"


validate_repo_name $distribution
config_mirror_file="${MIRROR_DIR}/$conf_mirror"

if [ ! -f "$config_mirror_file" ]; then
	echo "ERROR: $config_mirror_file: No such mirror definition file" >&2
	exit 1
fi

# source mirror configuration
. $config_mirror_file

if [ $all -eq 1 ]; then
	process_packages
elif [ -n "$force_package" ]; then
	process_package $force_package
fi
