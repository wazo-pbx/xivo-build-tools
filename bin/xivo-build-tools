#!/bin/bash
set -e

if [ $EUID == 0 ]; then
    echo "This script must not be run as root" 1>&2
    exit 1
fi

DPUT_DIR="/tmp/dput"
CONF_FILE="${CONF_FILE:-"/etc/xivo-build-tools/config"}"
GPG_KEY="84202FDB"

# source conffile
if [ -e $CONF_FILE ]; then
    . $CONF_FILE
else
    echo "$CONF_FILE: no such file" >&2
    exit 1
fi

export NAME="$DEBFULLNAME"
export EMAIL="$DEBEMAIL"

usage() {
    cat << EOF
You have to provide some informations to allow building:

    Usage: $(basename $0) [OPTION]

    Options:
        -d <distribution>: Distribution where to upload package (default: $DISTRIBUTION_DEFAULT)
        -b <branch_name>: Git branch to build from (default: $GIT_BRANCH_DEFAULT)
        -m <mirror>: Mirror where to upload package (default: $MIRROR_DEFAULT)
        -a: Build all packages
        -s: Build only source packages
        -S: Build all binary packages from sources
        -c: Build arch-dependent binary packages from sources
        -C: Build arch-independent binary packages from sources
        -p <package>: Build only <package>
        -f: Force package build without checking for changes in repository
        -v: Set xivo version
        -V: Set absolute package version
        -u: Use xivo version in filename (default: False)
        -h: show this help

EOF
    exit 0
}

valid_package() {
    local package="$1"

    if [[ $PACKAGES =~ $package ]]; then
        return 0
    else
        echo "Package: $package does not exist, see $CONF_FILE for more informations" >&2
        exit -1
    fi
}

cd_to_git_dir_package() {
    local package="$1"

    local package_dir="${PACKAGES_DIR}/${package}"
    cd "${package_dir}"
    return 0
}

git_remote_branch_exist() {
    local remote_branch="$1"

    git branch -r | grep -q "origin/$remote_branch"
    return $?
}

git_init_local_branch() {
    local local_branch="$1"

    git show-ref --verify --quiet "refs/heads/$local_branch"
    return $?
}

get_mirror_package_version() {
    local package="$1"

    case $package in
        "xivo-provisioning") local package="xivo-provd";;
        "xivo-dao") local package="xivo-libdao";;
        "xivo-dird") local package="xivo-libdird";;
    esac

    sudo apt-get update -yqq
    apt-cache show ${package}/${distribution} | grep '^Version:' | head -n1 | awk '{print $2}'
    return 0
}

get_source_version() {
    local package="$1"

    cd_to_git_dir_package $package

    # using date now instead of commit date
    #local git_timestamp=$(git log -1 --pretty='%ct')
    local timestamp=$(date -u +%Y%m%d.%H%M%S)
    local git_hash=$(git log -1 --pretty='%h')
    local computed="~${timestamp}.${git_hash}"

    if [ $use_version -eq 0 ]; then
        echo ${xivo_version}${computed}
    else
        echo ${computed}
    fi
    return 0
}

get_debian_version() {
    local package="$1"
    local source_version="$2"

    cd_to_git_dir_package $package

    local existing_version=$(get_mirror_package_version $package) || return 1

    if [ -z "$existing_version" ]; then
        # look for a package version
        local changelog=$(head -1 debian/changelog)
        if [[ "$changelog" =~ \((.*)\) ]] ; then
            existing_version=${BASH_REMATCH[1]}
        else
            echo "The first line of $dir/changelog is '$changelog' and does not match \\(.*\\)" >&2
            return 1
        fi
        # sanity check on the package name
        if ! [[ "$changelog" =~ ^$package ]] ; then
            echo "The first line of $dir/changelog is '$changelog' and does not start with $package" >&2
            return 2
        fi
    fi

    # extract the epoch, if any
    local epoch
    if [[ "$existing_version" =~ ([0-9]+:) ]] ; then
        epoch=${BASH_REMATCH[1]}
    fi

    local version=${epoch}${source_version}

    if ! dpkg --compare-versions $existing_version le $version ; then
        echo "Existing version of XiVO is ($existing_version) that is greater or equal (according to dpkg --compare-versions) than the version computed ($version)" >&2
        return 4
    fi

    echo $version
    return 0
}

generate_changelog() {
    local package="$1"
    local version="$2"

    echo "Generating changelog for package $package"

    cd_to_git_dir_package $package

    local message="$(git log -1 HEAD --pretty=format:%s)"
    if [ -n "$version" ]; then
        dch -b -v $version --distribution $distribution --force-distribution "$message"
    else
        dch -i --no-auto-nmu --distribution $distribution --force-distribution "$message"
    fi

    local changelog=$(head -1 debian/changelog)
    if [[ "$changelog" =~ \((.*)\) ]] ; then
        current_version=${BASH_REMATCH[1]}
    fi

    return 0
}

install_build_depends() {
    local package="$1"
    sudo apt-get build-dep -y --only-source $package/$distribution
    return 0
}


build_package_from_source() {
    local package="$1"

    local build_dir="$build_package_from_source_directory/$package"

    if [ -d $build_dir ]
    then
        rm -rf $build_dir
    fi

    mkdir -p $build_dir
    cd $build_dir

    sudo apt-get update -yq
    install_build_depends $package
    apt-get source --only-source $package/$distribution

    local directory_source=$(find  -maxdepth 1 -type d | grep ./)
    cd $directory_source
    case "$build_package_from_source" in
        arch-dependent) build_options="-B";;
        arch-independent) build_options="-A";;
        *) build_options="-b";;
    esac
    debuild --no-tgz-check --no-lintian --preserve-envvar=PATH $build_options -k$GPG_KEY
    cd $build_dir
    return 0
}

install_source_build_depends() {
    sudo mk-build-deps --install --remove --tool 'apt-get --no-install-recommends --assume-yes'
}

build_source_package() {
    local package="$1"
    local options="-d -k$GPG_KEY"

    cd_to_git_dir_package $package
    install_source_build_depends
    if debian/rules get-orig-source 2> /dev/null
    then
        echo "We have a get-orig-source"
        options="-sa "$options
    fi

    debuild --no-tgz-check -S $options
    return 0
}

build_module_kernel() {
    local package_source=dahdi-source
    local package_module=dahdi-linux
    local package_build=${package_module}-module
    local build_package_dahdi_module_directory=${build_package_from_source_directory}/${package_build}

    if [ -d ${build_package_dahdi_module_directory} ]; then
        rm -rf ${build_package_dahdi_module_directory}
    fi
    mkdir -p ${build_package_dahdi_module_directory}
    cd ${build_package_dahdi_module_directory}

    sudo apt-get update -yq
    sudo apt-get purge -y ${package_source}
    sudo apt-get install -y --force-yes module-assistant module-init-tools ${package_source}

    KVERS=$(echo $(for v in $(ls /boot/vmlinuz-*) ; do echo $(basename $v | sed -e 's|vmlinuz-||'); done) | sed 's/ /,/g')
    m-a prepare -i -t -l ${KVERS} -u ${build_package_dahdi_module_directory} ${package_module}
    SIGNCHANGES=1 m-a auto-build -i -t -l ${KVERS} -u ${build_package_dahdi_module_directory} ${package_module}

    debsign -k84202FDB $(ls *.changes)
    upload_to_mirror ${package_build}
}

clean_package() {
    local package="$1"

    cd_to_git_dir_package $package

    dh_clean
    return 0
}

build_dput_conf() {
    local dput_file="$1"

    cp ${DPUT_TPL_FILE} $dput_file
    sed -i "s|{{ distribution }}|${distribution}|g" $dput_file
    sed -i "s|{{ fqdn }}|${MIRROR_HOST}|g" $dput_file
    sed -i "s|{{ incoming }}|${MIRROR_INCOMING}|g" $dput_file
    return 0
}

upload_to_mirror() {
    if [ -z $1 ]; then
        local package=$(dpkg-parsechangelog | grep Source | awk -F ': ' '{print $NF}')
    else
        local package=$1
    fi

    if [ $build_only_source -eq 0 ]; then
        local changes_file=$(ls *.changes)
    else
        local version=$(echo "$2" | awk -F ':' '{print $NF}')
        local changes_file="../${package}_${version}_source.changes"
    fi

    local dput_file="${DPUT_DIR}/${package}.cf"

    if [ ! -d "$DPUT_DIR" ];then
        mkdir $DPUT_DIR
    fi

    build_dput_conf $dput_file
    dput -c $dput_file $distribution $changes_file
    return 0
}

process_packages() {
    for package in $PACKAGES; do
        process_package $package
    done
}

package_is_up_to_date() {
    local package="$1"

    echo "Checking updated package: $package"

    valid_package $package

    cd_to_git_dir_package $package

    git fetch origin
    local need_update="$(git log $branch_name_builded..origin/$branch_name_builded --oneline)"

    if [ "$need_update" == "" ]; then
        echo "Package $package already up-to-date."
        return 0
    else
        echo "Package $package needs update."
        return 1
    fi
}

extract_branch_infos() {
    local package="$1"

    echo "Extracting branch infos for package: $package"

    branch_name_builded="$branch_name"

    cd_to_git_dir_package $package

    if ! git_remote_branch_exist $branch_name ; then
        echo "Remote branch $branch_name does not exist" >&2
        return 1
    fi

    git_init_local_branch $branch_name_builded
    echo "$package fetch branch: <${branch_name_builded}>"

    return 0
}

prepare_repository() {
    local package="$1"

    echo "Initializing package: $package"

    cd $PACKAGES_DIR
    if [ ! -d "${package}/.git" ]; then
        echo "Cloning repository..."
        git clone ${GIT_URL}/${package}.git
        force_rebuild=1
    fi
    cd $package
    git fetch
    git clean -fxd
    git reset --hard
    return 0
}

update_git_repo() {
    git reset --hard
    git checkout $branch_name_builded
    git pull
}

process_package() {
    local package="$1"

    echo "Processing $package"

    prepare_repository $package

    if ! extract_branch_infos $package; then
        return 1
    fi

    if package_is_up_to_date $package && [ $force_rebuild -eq 0 ]; then
        echo
        return 0
    fi

    update_git_repo

    if [ -z "$package_version" -a -z "$xivo_version" ]; then
        generate_changelog $package
    else
        local debian_version
        if [ -n "$package_version" ]; then
            debian_version="$package_version"
        else
            local source_version=$(get_source_version $package) || return 1
            debian_version=$(get_debian_version $package $source_version) || return 1
        fi

        if [ -z "$debian_version" ]; then
            exit 1
        fi

        generate_changelog $package $debian_version
    fi

    if [ "$build_package_from_source" == "no" ]
    then
        build_source_package $package
        clean_package $package
    else
        build_package_from_source $package
    fi
    [ $? == 0 ] && upload_to_mirror $package $debian_version
    return 0
}

validate_repo_name() {
    local var="$1"
    case "$var" in
     *\ * )
        echo "ERROR: Invalid repository name, space is not allowed" >&2
        exit 1
        ;;
    *_* )
        echo "ERROR: Invalid repository name, underscore is not allowed" >&2
        exit 1
        ;;
    *)
        return 0
        ;;
    esac
}

if [ -z "$1" ]; then
    usage
fi

while getopts :d:p:v:b:m:V:afhsSkcC opt
do
    case $opt in
        d) distribution=$OPTARG;;
        p) force_package=$OPTARG;;
        v) force_xivo_version=$OPTARG;;
        b) branch_name=$OPTARG;;
        s) build_only_source=1;;
        S) build_package_from_source='all';;
        m) conf_mirror=$OPTARG;;
        V) force_package_version=$OPTARG;;
        k) build_module_kernel=1;;
        a) all=1;;
        f) force_rebuild=1;;
        u) use_version=1;;
        c) build_package_from_source='arch-dependent';;
        C) build_package_from_source='arch-independent';;
        h) usage;;
        '?') echo "$0 : option $OPTARG is not valid" >&2
            usage
        ;;
    esac
done

distribution="${distribution:-"${DISTRIBUTION_DEFAULT}"}"
branch_name="${branch_name:-"${GIT_BRANCH_DEFAULT}"}"
conf_mirror="${conf_mirror:-"${MIRROR_DEFAULT}"}"
xivo_version="${force_xivo_version:-""}"
package_version="${force_package_version:-""}"
all="${all:-"0"}"
build_only_source="${build_only_source:-"0"}"
build_package_from_source="${build_package_from_source:-"no"}"
build_module_kernel="${build_module_kernel:-"0"}"
force_rebuild="${force_rebuild:-"0"}"
use_version="${use_version:-"0"}"


validate_repo_name $distribution
config_mirror_file="${MIRROR_DIR}/$conf_mirror"
build_package_from_source_directory="${HOME}/build_from_sources"

if [ ! -f "$config_mirror_file" ]; then
    echo "ERROR: $config_mirror_file: No such mirror definition file" >&2
    exit 1
fi

# source mirror configuration
. $config_mirror_file

if [ $build_module_kernel -eq 1 ]; then
    build_module_kernel
    exit 0
fi

if [ $all -eq 1 ]; then
    process_packages
elif [ -n "$force_package" ]; then
    process_package $force_package
fi
